"""Property tests for adapter IR output determinism.

**Feature: adapter-refactor, Property 1: IR Output Determinism**
**Validates: Requirements 4.4**

For any valid source code directory, the IR generated by the adapter
should be identical across multiple invocations with the same input.
"""

from __future__ import annotations

from pathlib import Path

import pytest
from hypothesis import given, settings, strategies as st

from synapse.adapters import GoAdapter, JavaAdapter


# Paths to test fixtures
JAVA_SAMPLE_PATH = Path(__file__).parent.parent / "fixtures" / "java_sample"
GO_SAMPLE_PATH = Path(__file__).parent.parent / "fixtures" / "go_sample"


@st.composite
def project_id_strategy(draw: st.DrawFn) -> str:
    """Generate a valid project ID."""
    suffix = draw(st.integers(min_value=1, max_value=9999))
    return f"test-project-{suffix}"


@given(project_id=project_id_strategy())
@settings(max_examples=100)
def test_java_adapter_determinism(project_id: str) -> None:
    """
    **Feature: adapter-refactor, Property 1: IR Output Determinism**
    **Validates: Requirements 4.4**

    For any project ID, the Java adapter should produce identical IR
    when analyzing the same source code multiple times.
    """
    if not JAVA_SAMPLE_PATH.exists():
        pytest.skip("Java sample fixtures not found")

    # Create two separate adapter instances
    adapter1 = JavaAdapter(project_id)
    adapter2 = JavaAdapter(project_id)

    # Analyze the same source code
    ir1 = adapter1.analyze(JAVA_SAMPLE_PATH)
    ir2 = adapter2.analyze(JAVA_SAMPLE_PATH)

    # Verify determinism: same input should produce same output
    assert ir1.version == ir2.version
    assert ir1.language_type == ir2.language_type
    assert set(ir1.modules.keys()) == set(ir2.modules.keys())
    assert set(ir1.types.keys()) == set(ir2.types.keys())
    assert set(ir1.callables.keys()) == set(ir2.callables.keys())

    # Verify module contents
    for mod_id in ir1.modules:
        m1, m2 = ir1.modules[mod_id], ir2.modules[mod_id]
        assert m1.name == m2.name
        assert m1.qualified_name == m2.qualified_name
        assert m1.path == m2.path

    # Verify type contents
    for type_id in ir1.types:
        t1, t2 = ir1.types[type_id], ir2.types[type_id]
        assert t1.name == t2.name
        assert t1.qualified_name == t2.qualified_name
        assert t1.kind == t2.kind

    # Verify callable contents
    for call_id in ir1.callables:
        c1, c2 = ir1.callables[call_id], ir2.callables[call_id]
        assert c1.name == c2.name
        assert c1.qualified_name == c2.qualified_name
        assert c1.kind == c2.kind
        assert c1.signature == c2.signature


@given(project_id=project_id_strategy())
@settings(max_examples=100)
def test_go_adapter_determinism(project_id: str) -> None:
    """
    **Feature: adapter-refactor, Property 1: IR Output Determinism**
    **Validates: Requirements 4.4**

    For any project ID, the Go adapter should produce identical IR
    when analyzing the same source code multiple times.
    """
    if not GO_SAMPLE_PATH.exists():
        pytest.skip("Go sample fixtures not found")

    # Create two separate adapter instances
    adapter1 = GoAdapter(project_id)
    adapter2 = GoAdapter(project_id)

    # Analyze the same source code
    ir1 = adapter1.analyze(GO_SAMPLE_PATH)
    ir2 = adapter2.analyze(GO_SAMPLE_PATH)

    # Verify determinism: same input should produce same output
    assert ir1.version == ir2.version
    assert ir1.language_type == ir2.language_type
    assert set(ir1.modules.keys()) == set(ir2.modules.keys())
    assert set(ir1.types.keys()) == set(ir2.types.keys())
    assert set(ir1.callables.keys()) == set(ir2.callables.keys())

    # Verify module contents
    for mod_id in ir1.modules:
        m1, m2 = ir1.modules[mod_id], ir2.modules[mod_id]
        assert m1.name == m2.name
        assert m1.qualified_name == m2.qualified_name
        assert m1.path == m2.path

    # Verify type contents
    for type_id in ir1.types:
        t1, t2 = ir1.types[type_id], ir2.types[type_id]
        assert t1.name == t2.name
        assert t1.qualified_name == t2.qualified_name
        assert t1.kind == t2.kind

    # Verify callable contents
    for call_id in ir1.callables:
        c1, c2 = ir1.callables[call_id], ir2.callables[call_id]
        assert c1.name == c2.name
        assert c1.qualified_name == c2.qualified_name
        assert c1.kind == c2.kind
        assert c1.signature == c2.signature
